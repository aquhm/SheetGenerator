namespace SheetGenerator;

public static class TemplateResource
{
    private static readonly Dictionary<string, string> Templates = new()
    {
            {
                    "CSharp/RecordTemplate", @"/*
 * THIS CODE WAS GENERATED BY SHEET-GENERATOR.
 *
 * CHANGES TO THIS FILE MAY CAUSE INCORRECT BEHAVIOR AND WILL BE LOST IF
 * THE CODE IS REGENERATED.
 */

using System.Text;
using System.Runtime.CompilerServices;
using System.Buffers;
using MessagePack;
using SheetGenerator.IO;
using SheetGenerator.Configuration;

namespace {Namespace}
{
    [MessagePackObject]
    public sealed partial class {TableName}Record : IEquatable<{TableName}Record>
    {
        #region Fields
{Properties}
        #endregion

        #region Binary IO
        [SerializationConstructor]
        public {TableName}Record() { }

        public void Read(TableBinaryReader reader, uint[] tags)
        {
            if (reader == null)
            {
                throw new ArgumentNullException(nameof(reader));
            }

            if (tags == null)
            {
                throw new ArgumentNullException(nameof(tags));
            }

            try
            {
                var bytes = reader.GetRemainingBytes();
                if (bytes.Length == 0)
                    throw new InvalidDataException(""No data available to read"");

                var record = MessagePackSerializer.Deserialize<{TableName}Record>(bytes, MessagePackConfig.Options);
                CopyFrom(record);
            }
            catch (Exception ex)
            {
                throw new InvalidDataException($""Failed to read {nameof({TableName}Record)}"", ex);
            }
        }

        private void CopyFrom({TableName}Record source)
        {
{CopyFromContent}
        }

        public void Serialize(IBufferWriter<byte> writer)
        {
            MessagePackSerializer.Serialize(writer, this);
        }

        public static {TableName}Record Deserialize(ReadOnlyMemory<byte> bytes)
        {
            return MessagePackSerializer.Deserialize<{TableName}Record>(bytes);
        }
        #endregion

        #region ToString
        public override string ToString()
        {
            return ToStringInternal();
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private string ToStringInternal()
        {
            var sb = new StringBuilder(256);
            sb.Append('{');
{ToStringContent}
            sb.Append('}');
            return sb.ToString();
        }
        #endregion

        #region Equality & GetHashCode
        public bool Equals({TableName}Record other)
        {
            if (ReferenceEquals(null, other)) return false;
            if (ReferenceEquals(this, other)) return true;
{EqualityContent}
        }

        public override bool Equals(object obj)
        {
            return ReferenceEquals(this, obj) || (obj is {TableName}Record other && Equals(other));
        }

        public override int GetHashCode()
        {
            HashCode hash = new();
{HashContent}
            return hash.ToHashCode();
        }

        public static bool operator ==({TableName}Record left, {TableName}Record right)
        {
            return Equals(left, right);
        }

        public static bool operator !=({TableName}Record left, {TableName}Record right)
        {
            return !Equals(left, right);
        }
        #endregion

        #region Indexer
        private readonly struct FieldInfo
        {
            public readonly int Index;
            public readonly Func<{TableName}Record, object> Accessor;

            public FieldInfo(int index, Func<{TableName}Record, object> accessor)
            {
                Index = index;
                Accessor = accessor;
            }
        }

        private static readonly Dictionary<string, FieldInfo> _fieldInfos;
        private static readonly FieldInfo[] _indexedFields;

        static {TableName}Record()
        {
            _fieldInfos = new Dictionary<string, FieldInfo>(StringComparer.Ordinal)
            {
{FieldInfoContent}
            };

            _indexedFields = new FieldInfo[]
            {
{IndexedFieldsContent}
            };
        }

        public object this[int fieldIndex]
        {
            get
            {
                if ((uint)fieldIndex >= _indexedFields.Length)
                    throw new ArgumentOutOfRangeException(nameof(fieldIndex));
                return _indexedFields[fieldIndex].Accessor(this);
            }
        }

        public object this[string fieldName]
        {
            get
            {
                if (fieldName == null)
                {
                    throw new ArgumentNullException(nameof(fieldName));
                }

                if (!_fieldInfos.TryGetValue(fieldName, out var fieldInfo))
                    throw new KeyNotFoundException($""Field '{fieldName}' not found."");
                return fieldInfo.Accessor(this);
            }
        }
        #endregion
    }
}
"
            },
            {
                    "CSharp/TableTemplate", @"/*
* THIS CODE WAS GENERATED BY SHEET-GENERATOR.
*
* CHANGES TO THIS FILE MAY CAUSE INCORRECT BEHAVIOR AND WILL BE LOST IF
* THE CODE IS REGENERATED.
*/

using System.Diagnostics.CodeAnalysis;

namespace {Namespace}
{
   /// <summary>{TableDescription}</summary>
   public sealed class {TableName}Table : TableBase<{TableName}Record>
   {
       public {TableName}Record GetByIndex(int index)
       {
           if (_recordsByIndex.TryGetValue(index, out var record))
               return record;
           throw new KeyNotFoundException($""Record with index {index} not found."");
       }

       public bool TryGetByIndex(int index, out {TableName}Record? record)
       {
           return _recordsByIndex.TryGetValue(index, out record);
       }

       public {TableName}Record GetByKey(string key)
       {
           ArgumentNullException.ThrowIfNull(key);
           if (_recordsByKey.TryGetValue(key, out var record))
               return record;
           throw new KeyNotFoundException($""Record with key {key} not found."");
       }

       public bool TryGetByKey(string key, [NotNullWhen(true)] out {TableName}Record? record)
       {
           ArgumentNullException.ThrowIfNull(key);
           return _recordsByKey.TryGetValue(key, out record);
       }

       public object[][] BuildObjectValueMap()
       {
          var result = new object[_records.Count][];
          for (int i = 0; i < _records.Count; i++)
          {
              var record = _records[i];
              result[i] = new object[] { {BuildObjectMapParams} };
          }
          return result;
       }
   }
}
"
            },
            {
                    "CSharp/SystemTemplate", @"/*
 * THIS CODE WAS GENERATED BY SHEET-GENERATOR.
 *
 * CHANGES TO THIS FILE MAY CAUSE INCORRECT BEHAVIOR AND WILL BE LOST IF
 * THE CODE IS REGENERATED.
 */

using System;
using System.Buffers;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Text.Json;
using MessagePack;
using SheetGenerator.Configuration;
using SheetGenerator.IO;
using SheetGenerator.Models;

namespace {Namespace}
{
    public interface ITable
    {
        Task ReadAsync(string filename, CancellationToken cancellationToken = default);
        void Clear();
    }

    public sealed class TableSystem
    {
        private static TableSystem _instance;
        public static TableSystem Instance
        {
            get
            {
                if (_instance == null)
                    _instance = new TableSystem();
                return _instance;
            }
        }

        private readonly List<ITable> _tables = new();

        public static ReadAllBytesAsyncDelegate ReadAllBytesAsync = async (string filename, CancellationToken cancellationToken = default) => {

            if (filename == null)
            {
                throw new ArgumentNullException(nameof(filename));
            }

            return await File.ReadAllBytesAsync(filename, cancellationToken);
        };

        public delegate Task<byte[]> ReadAllBytesAsyncDelegate(string filename, CancellationToken cancellationToken = default);

        #region Properties
{Properties}
        #endregion

        public async Task InitializeAsync(string basePath)
        {
            try
            {
                var tasks = new List<Task>
                {
{InitializeContent}
                };

                await Task.WhenAll(tasks);
            }
            catch (Exception ex)
            {
                throw new AggregateException(""Failed to initialize tables"", ex);
            }
        }

        private async Task InitializeTableAsync<T>(string basePath, string filename, Action<T> setTable) where T : class, ITable, new()
        {
            var table = new T();
            var filePath = Path.Combine(basePath, filename);
            await table.ReadAsync(filePath);
            _tables.Add(table);
            setTable(table);
        }

        public void Release()
        {
            foreach (var table in _tables)
            {
                table?.Clear();
            }
            _instance = null;
        }

        public static object? GetDefaultValue(Type type)
        {
            return type switch
            {
                Type t when t == typeof(string) => string.Empty,
                Type t when t == typeof(int) => 0,
                Type t when t == typeof(float) => 0f,
                Type t when t == typeof(double) => 0d,
                Type t when t == typeof(long) => 0L,
                Type t when t == typeof(bool) => false,
                Type t when t == typeof(DateTime) => DateTime.MinValue,
                Type t when t.IsValueType => Activator.CreateInstance(t),
                _ => null
            };
        }

        #region Table Handling
        private static T CreateRecordFromData<T>(RecordData recordData, List<Column> columns) where T : class, new()
        {
            var record = new T();
            var recordType = typeof(T);

            foreach (var column in columns)
            {
                if (recordData.Values.TryGetValue(column.Name, out var value))
                {
                    var prop = recordType.GetProperty(column.Name);
                    if (prop != null)
                    {
                        SetPropertyValue(record, prop, value);
                    }
                }
            }

            return record;
        }

        private static void SetPropertyValue<T>(T record, PropertyInfo prop, object value)
        {
            if (value == null || string.IsNullOrEmpty(value.ToString()))
            {
                prop.SetValue(record, GetDefaultValue(prop.PropertyType));
                return;
            }

            try
            {
                var convertedValue = Convert.ChangeType(value.ToString(), prop.PropertyType);
                prop.SetValue(record, convertedValue);
            }
            catch
            {
                prop.SetValue(record, GetDefaultValue(prop.PropertyType));
            }
        }
        #endregion
    }

    public abstract class TableBase<TRecord> : ITable where TRecord : class, new()
    {
        protected readonly List<TRecord> _records;
        protected readonly Dictionary<int, TRecord> _recordsByIndex;
        protected readonly Dictionary<string, TRecord> _recordsByKey;
        protected TableMetadata _metadata;

        protected TableBase()
        {
            _records = new List<TRecord>();
            _recordsByIndex = new Dictionary<int, TRecord>();
            _recordsByKey = new Dictionary<string, TRecord>(StringComparer.Ordinal);
        }

        public string TableName => _metadata?.TableName;
        public string Description => _metadata?.Description;
        public int ColumnCount => _metadata?.ColumnCount ?? 0;
        public int RowCount => _metadata?.RowCount ?? 0;
        public IReadOnlyList<Column> Columns => _metadata?.Columns;
        public IReadOnlyList<TRecord> Records => _records;
        public IReadOnlyDictionary<int, TRecord> RecordsByIndex => _recordsByIndex;
        public IReadOnlyDictionary<string, TRecord> RecordsByKey => _recordsByKey;

        public virtual async Task ReadAsync(string filename, CancellationToken cancellationToken = default)
        {
            if (filename == null)
            {
                throw new ArgumentNullException(nameof(filename));
            }

            bool isJson = Path.GetExtension(filename).Equals("".json"", StringComparison.OrdinalIgnoreCase);

            if (isJson)
            {
                var jsonContent = await File.ReadAllTextAsync(filename, cancellationToken);
                using var reader = new TableJsonReader(jsonContent);
                ReadJson(reader);
            }
            else
            {
                var bytes = await TableSystem.ReadAllBytesAsync(filename, cancellationToken);
                if (bytes == null)
                    throw new InvalidOperationException($""Cannot read file: {filename}"");

                using var reader = new TableBinaryReader(bytes);
                ReadBinary(reader);
            }
        }

        protected virtual void ReadBinary(TableBinaryReader reader)
        {
            if (reader == null)
            {
                throw new ArgumentNullException(nameof(reader));
            }

            try
            {
                var tableData = reader.ReadMessagePackData<TableData>(MessagePackConfig.Options);
                if (tableData == null)
                    throw new InvalidDataException(""Table data is null"");

                ReadTableData(tableData);
            }
            catch (Exception ex)
            {
                throw new InvalidDataException($""Failed to read {GetType().Name}"", ex);
            }
        }

        protected virtual void ReadJson(TableJsonReader reader)
        {
            if (reader == null)
            {
                throw new ArgumentNullException(nameof(reader));
            }

            try
            {
                var tableData = reader.ReadJsonData<TableData>();
                ReadTableData(tableData);
            }
            catch (Exception ex)
            {
                throw new InvalidDataException($""Failed to read {GetType().Name} from JSON"", ex);
            }
        }

        private void ReadTableData(TableData tableData)
        {
            _metadata = new TableMetadata
            {
                TableName = tableData.Name,
                ColumnCount = tableData.ColumnCount,
                RowCount = tableData.RecordCount,
                Columns = tableData.Columns
            };

            var records = new List<TRecord>();
            var recordType = typeof(TRecord);

            foreach (var recordData in tableData.Records)
            {
                var record = new TRecord();
                foreach (var column in tableData.Columns)
                {
                    if (recordData.Values.TryGetValue(column.Name, out var value))
                    {
                        var prop = recordType.GetProperty(column.Name);
                        if (prop != null)
                        {
                            if (value == null || string.IsNullOrEmpty(value.ToString()))
                            {
                                prop.SetValue(record, TableSystem.GetDefaultValue(prop.PropertyType));
                            }
                            else
                            {
                                var convertedValue = Convert.ChangeType(value.ToString(), prop.PropertyType);
                                prop.SetValue(record, convertedValue);
                            }
                        }
                    }
                }
                records.Add(record);
            }

            BuildIndices(records);
        }

        protected virtual void BuildIndices(List<TRecord> records)
        {
            _recordsByIndex.Clear();
            _recordsByKey.Clear();
            _records.Clear();

            foreach (var record in records)
            {
                var indexProp = record.GetType().GetProperty(""Index"");
                var keyProp = record.GetType().GetProperty(""Key"");

                var index = (int)indexProp.GetValue(record);
                var key = (string)keyProp.GetValue(record);

                if (index <= 0)
                    throw new InvalidDataException($""Invalid record index: {index}"");
                if (string.IsNullOrEmpty(key))
                    throw new InvalidDataException($""Empty key in record with index: {index}"");

                _recordsByIndex[index] = record;
                _recordsByKey[key] = record;
                _records.Add(record);
            }
        }

        public virtual void Clear()
        {
            _records.Clear();
            _recordsByIndex.Clear();
            _recordsByKey.Clear();
        }
    }
}
"
            }
    };

    public static string GetTemplate(string name)
    {
        if (!Templates.TryGetValue(name, out var template))
        {
            throw new KeyNotFoundException($"Template '{name}' not found.");
        }

        return template;
    }

    public static IEnumerable<string> GetTemplateNames()
    {
        return Templates.Keys;
    }
}
