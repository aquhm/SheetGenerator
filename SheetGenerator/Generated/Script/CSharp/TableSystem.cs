/*
 * THIS CODE WAS GENERATED BY SHEET-GENERATOR.
 *
 * CHANGES TO THIS FILE MAY CAUSE INCORRECT BEHAVIOR AND WILL BE LOST IF
 * THE CODE IS REGENERATED.
 */

using System;
using System.Buffers;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Text.Json;
using MessagePack;
using SheetGenerator.Configuration;
using SheetGenerator.IO;
using SheetGenerator.Models;

namespace StaticData.Tables
{
    public interface ITable
    {
        Task ReadAsync(string filename, CancellationToken cancellationToken = default);
        void Clear();
    }

    public sealed class TableSystem
    {
        private static TableSystem _instance;
        public static TableSystem Instance
        {
            get
            {
                if (_instance == null)
                    _instance = new TableSystem();
                return _instance;
            }
        }

        private readonly List<ITable> _tables = new();

        public static ReadAllBytesAsyncDelegate ReadAllBytesAsync = async (string filename, CancellationToken cancellationToken = default) => {

            if (filename == null)
            {
                throw new ArgumentNullException(nameof(filename));
            }

            return await File.ReadAllBytesAsync(filename, cancellationToken);
        };

        public delegate Task<byte[]> ReadAllBytesAsyncDelegate(string filename, CancellationToken cancellationToken = default);

        #region Properties
        public static LocalizationTable Localization { get; set; }
        public static ClientTestTable ClientTest { get; set; }
        public static ClientTest2Table ClientTest2 { get; set; }
        public static ClientTest3Table ClientTest3 { get; set; }
        public static ClientTest4Table ClientTest4 { get; set; }
        #endregion

        public async Task InitializeAsync(string basePath)
        {
            try
            {
                var tasks = new List<Task>
                {
                    InitializeTableAsync<LocalizationTable>(basePath, "LocalizationData.json", table => Localization = table),
                    InitializeTableAsync<ClientTestTable>(basePath, "ClientTestData.json", table => ClientTest = table),
                    InitializeTableAsync<ClientTest2Table>(basePath, "ClientTest2Data.json", table => ClientTest2 = table),
                    InitializeTableAsync<ClientTest3Table>(basePath, "ClientTest3Data.json", table => ClientTest3 = table),
                    InitializeTableAsync<ClientTest4Table>(basePath, "ClientTest4Data.json", table => ClientTest4 = table),
                };

                await Task.WhenAll(tasks);
            }
            catch (Exception ex)
            {
                throw new AggregateException("Failed to initialize tables", ex);
            }
        }

        private async Task InitializeTableAsync<T>(string basePath, string filename, Action<T> setTable) where T : class, ITable, new()
        {
            var table = new T();
            var filePath = Path.Combine(basePath, filename);
            await table.ReadAsync(filePath);
            _tables.Add(table);
            setTable(table);
        }

        public void Release()
        {
            foreach (var table in _tables)
            {
                table?.Clear();
            }
            _instance = null;
        }

        public static object? GetDefaultValue(Type type)
        {
            return type switch
            {
                Type t when t == typeof(string) => string.Empty,
                Type t when t == typeof(int) => 0,
                Type t when t == typeof(float) => 0f,
                Type t when t == typeof(double) => 0d,
                Type t when t == typeof(long) => 0L,
                Type t when t == typeof(bool) => false,
                Type t when t == typeof(DateTime) => DateTime.MinValue,
                Type t when t.IsValueType => Activator.CreateInstance(t),
                _ => null
            };
        }

        #region Table Handling
        private static T CreateRecordFromData<T>(RecordData recordData, List<Column> columns) where T : class, new()
        {
            var record = new T();
            var recordType = typeof(T);

            foreach (var column in columns)
            {
                if (recordData.Values.TryGetValue(column.Name, out var value))
                {
                    var prop = recordType.GetProperty(column.Name);
                    if (prop != null)
                    {
                        SetPropertyValue(record, prop, value);
                    }
                }
            }

            return record;
        }

        private static void SetPropertyValue<T>(T record, PropertyInfo prop, object value)
        {
            if (value == null || string.IsNullOrEmpty(value.ToString()))
            {
                prop.SetValue(record, GetDefaultValue(prop.PropertyType));
                return;
            }

            try
            {
                var convertedValue = Convert.ChangeType(value.ToString(), prop.PropertyType);
                prop.SetValue(record, convertedValue);
            }
            catch
            {
                prop.SetValue(record, GetDefaultValue(prop.PropertyType));
            }
        }
        #endregion
    }

    public abstract class TableBase<TRecord> : ITable where TRecord : class, new()
    {
        protected readonly List<TRecord> _records;
        protected readonly Dictionary<int, TRecord> _recordsByIndex;
        protected readonly Dictionary<string, TRecord> _recordsByKey;
        protected TableMetadata _metadata;

        protected TableBase()
        {
            _records = new List<TRecord>();
            _recordsByIndex = new Dictionary<int, TRecord>();
            _recordsByKey = new Dictionary<string, TRecord>(StringComparer.Ordinal);
        }

        public string TableName => _metadata?.TableName;
        public string Description => _metadata?.Description;
        public int ColumnCount => _metadata?.ColumnCount ?? 0;
        public int RowCount => _metadata?.RowCount ?? 0;
        public IReadOnlyList<Column> Columns => _metadata?.Columns;
        public IReadOnlyList<TRecord> Records => _records;
        public IReadOnlyDictionary<int, TRecord> RecordsByIndex => _recordsByIndex;
        public IReadOnlyDictionary<string, TRecord> RecordsByKey => _recordsByKey;

        public virtual async Task ReadAsync(string filename, CancellationToken cancellationToken = default)
        {
            if (filename == null)
            {
                throw new ArgumentNullException(nameof(filename));
            }

            bool isJson = Path.GetExtension(filename).Equals(".json", StringComparison.OrdinalIgnoreCase);

            if (isJson)
            {
                var jsonContent = await File.ReadAllTextAsync(filename, cancellationToken);
                using var reader = new TableJsonReader(jsonContent);
                ReadJson(reader);
            }
            else
            {
                var bytes = await TableSystem.ReadAllBytesAsync(filename, cancellationToken);
                if (bytes == null)
                    throw new InvalidOperationException($"Cannot read file: {filename}");

                using var reader = new TableBinaryReader(bytes);
                ReadBinary(reader);
            }
        }

        protected virtual void ReadBinary(TableBinaryReader reader)
        {
            if (reader == null)
            {
                throw new ArgumentNullException(nameof(reader));
            }

            try
            {
                var tableData = reader.ReadMessagePackData<TableData>(MessagePackConfig.Options);
                if (tableData == null)
                    throw new InvalidDataException("Table data is null");

                ReadTableData(tableData);
            }
            catch (Exception ex)
            {
                throw new InvalidDataException($"Failed to read {GetType().Name}", ex);
            }
        }

        protected virtual void ReadJson(TableJsonReader reader)
        {
            if (reader == null)
            {
                throw new ArgumentNullException(nameof(reader));
            }

            try
            {
                var tableData = reader.ReadJsonData<TableData>();
                ReadTableData(tableData);
            }
            catch (Exception ex)
            {
                throw new InvalidDataException($"Failed to read {GetType().Name} from JSON", ex);
            }
        }

        private void ReadTableData(TableData tableData)
        {
            _metadata = new TableMetadata
            {
                TableName = tableData.Name,
                ColumnCount = tableData.ColumnCount,
                RowCount = tableData.RecordCount,
                Columns = tableData.Columns
            };

            var records = new List<TRecord>();
            var recordType = typeof(TRecord);

            foreach (var recordData in tableData.Records)
            {
                var record = new TRecord();
                foreach (var column in tableData.Columns)
                {
                    if (recordData.Values.TryGetValue(column.Name, out var value))
                    {
                        var prop = recordType.GetProperty(column.Name);
                        if (prop != null)
                        {
                            if (value == null || string.IsNullOrEmpty(value.ToString()))
                            {
                                prop.SetValue(record, TableSystem.GetDefaultValue(prop.PropertyType));
                            }
                            else
                            {
                                var convertedValue = Convert.ChangeType(value.ToString(), prop.PropertyType);
                                prop.SetValue(record, convertedValue);
                            }
                        }
                    }
                }
                records.Add(record);
            }

            BuildIndices(records);
        }

        protected virtual void BuildIndices(List<TRecord> records)
        {
            _recordsByIndex.Clear();
            _recordsByKey.Clear();
            _records.Clear();

            foreach (var record in records)
            {
                var indexProp = record.GetType().GetProperty("Index");
                var keyProp = record.GetType().GetProperty("Key");

                var index = (int)indexProp.GetValue(record);
                var key = (string)keyProp.GetValue(record);

                if (index <= 0)
                    throw new InvalidDataException($"Invalid record index: {index}");
                if (string.IsNullOrEmpty(key))
                    throw new InvalidDataException($"Empty key in record with index: {index}");

                _recordsByIndex[index] = record;
                _recordsByKey[key] = record;
                _records.Add(record);
            }
        }

        public virtual void Clear()
        {
            _records.Clear();
            _recordsByIndex.Clear();
            _recordsByKey.Clear();
        }
    }
}
