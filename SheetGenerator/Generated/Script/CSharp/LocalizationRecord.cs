/*
 * THIS CODE WAS GENERATED BY SHEET-GENERATOR.
 *
 * CHANGES TO THIS FILE MAY CAUSE INCORRECT BEHAVIOR AND WILL BE LOST IF
 * THE CODE IS REGENERATED.
 */

using System.Text;
using System.Runtime.CompilerServices;
using System.Buffers;
using MessagePack;
using SheetGenerator.IO;
using SheetGenerator.Configuration;

namespace StaticData.Tables
{
    [MessagePackObject]
    public sealed partial class LocalizationRecord : IEquatable<LocalizationRecord>
    {
        #region Fields
        /// <summary>인덱스(필수)</summary>
        [Key(0)]
        public int Index { get; private set; }

        /// <summary>스트링 키</summary>
        [Key(1)]
        public string Key { get; private set; }

        /// <summary>설명</summary>
        [Key(2)]
        public string Description { get; private set; }

        /// <summary>영어</summary>
        [Key(3)]
        public string English { get; private set; }

        /// <summary>한글</summary>
        [Key(4)]
        public string Korean { get; private set; }

        /// <summary>영어</summary>
        [Key(5)]
        public string Spanish { get; private set; }

        /// <summary>영어</summary>
        [Key(6)]
        public string Chinese { get; private set; }

        /// <summary>영어</summary>
        [Key(7)]
        public string French { get; private set; }

        /// <summary>영어</summary>
        [Key(8)]
        public string German { get; private set; }

        /// <summary>영어</summary>
        [Key(9)]
        public string Indonesian { get; private set; }

        /// <summary>영어</summary>
        [Key(10)]
        public string Japanese { get; private set; }

        /// <summary>영어</summary>
        [Key(11)]
        public string Portuguese { get; private set; }

        /// <summary>영어</summary>
        [Key(12)]
        public string Russian { get; private set; }

        /// <summary>영어</summary>
        [Key(13)]
        public string Vietnamese { get; private set; }

        /// <summary>영어</summary>
        [Key(14)]
        public string Italian { get; private set; }

        /// <summary>영어</summary>
        [Key(15)]
        public string Arabic { get; private set; }
        #endregion

        #region Binary IO
        [SerializationConstructor]
        public LocalizationRecord() { }

        public void Read(TableBinaryReader reader, uint[] tags)
        {
            if (reader == null)
            {
                throw new ArgumentNullException(nameof(reader));
            }

            if (tags == null)
            {
                throw new ArgumentNullException(nameof(tags));
            }

            try
            {
                var bytes = reader.GetRemainingBytes();
                if (bytes.Length == 0)
                    throw new InvalidDataException("No data available to read");

                var record = MessagePackSerializer.Deserialize<LocalizationRecord>(bytes, MessagePackConfig.Options);
                CopyFrom(record);
            }
            catch (Exception ex)
            {
                throw new InvalidDataException($"Failed to read {nameof(LocalizationRecord)}", ex);
            }
        }

        private void CopyFrom(LocalizationRecord source)
        {
            Index = source.Index;
            Key = source.Key;
            Description = source.Description;
            English = source.English;
            Korean = source.Korean;
            Spanish = source.Spanish;
            Chinese = source.Chinese;
            French = source.French;
            German = source.German;
            Indonesian = source.Indonesian;
            Japanese = source.Japanese;
            Portuguese = source.Portuguese;
            Russian = source.Russian;
            Vietnamese = source.Vietnamese;
            Italian = source.Italian;
            Arabic = source.Arabic;
        }

        public void Serialize(IBufferWriter<byte> writer)
        {
            MessagePackSerializer.Serialize(writer, this);
        }

        public static LocalizationRecord Deserialize(ReadOnlyMemory<byte> bytes)
        {
            return MessagePackSerializer.Deserialize<LocalizationRecord>(bytes);
        }
        #endregion

        #region ToString
        public override string ToString()
        {
            return ToStringInternal();
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private string ToStringInternal()
        {
            var sb = new StringBuilder(256);
            sb.Append('{');
            sb.Append("\"Index\":");
            StringFormatter.Format(Index, sb);
            sb.Append("\"Key\":");
            StringFormatter.Format(Key, sb);
            sb.Append("\"Description\":");
            StringFormatter.Format(Description, sb);
            sb.Append("\"English\":");
            StringFormatter.Format(English, sb);
            sb.Append("\"Korean\":");
            StringFormatter.Format(Korean, sb);
            sb.Append("\"Spanish\":");
            StringFormatter.Format(Spanish, sb);
            sb.Append("\"Chinese\":");
            StringFormatter.Format(Chinese, sb);
            sb.Append("\"French\":");
            StringFormatter.Format(French, sb);
            sb.Append("\"German\":");
            StringFormatter.Format(German, sb);
            sb.Append("\"Indonesian\":");
            StringFormatter.Format(Indonesian, sb);
            sb.Append("\"Japanese\":");
            StringFormatter.Format(Japanese, sb);
            sb.Append("\"Portuguese\":");
            StringFormatter.Format(Portuguese, sb);
            sb.Append("\"Russian\":");
            StringFormatter.Format(Russian, sb);
            sb.Append("\"Vietnamese\":");
            StringFormatter.Format(Vietnamese, sb);
            sb.Append("\"Italian\":");
            StringFormatter.Format(Italian, sb);
            sb.Append("\"Arabic\":");
            StringFormatter.Format(Arabic, sb);

            sb.Append('}');
            return sb.ToString();
        }
        #endregion

        #region Equality & GetHashCode
        public bool Equals(LocalizationRecord other)
        {
            if (ReferenceEquals(null, other)) return false;
            if (ReferenceEquals(this, other)) return true;
            if (!Index.Equals(other.Index)) return false;
            if (!string.Equals(Key, other.Key, StringComparison.Ordinal)) return false;
            if (!string.Equals(Description, other.Description, StringComparison.Ordinal)) return false;
            if (!string.Equals(English, other.English, StringComparison.Ordinal)) return false;
            if (!string.Equals(Korean, other.Korean, StringComparison.Ordinal)) return false;
            if (!string.Equals(Spanish, other.Spanish, StringComparison.Ordinal)) return false;
            if (!string.Equals(Chinese, other.Chinese, StringComparison.Ordinal)) return false;
            if (!string.Equals(French, other.French, StringComparison.Ordinal)) return false;
            if (!string.Equals(German, other.German, StringComparison.Ordinal)) return false;
            if (!string.Equals(Indonesian, other.Indonesian, StringComparison.Ordinal)) return false;
            if (!string.Equals(Japanese, other.Japanese, StringComparison.Ordinal)) return false;
            if (!string.Equals(Portuguese, other.Portuguese, StringComparison.Ordinal)) return false;
            if (!string.Equals(Russian, other.Russian, StringComparison.Ordinal)) return false;
            if (!string.Equals(Vietnamese, other.Vietnamese, StringComparison.Ordinal)) return false;
            if (!string.Equals(Italian, other.Italian, StringComparison.Ordinal)) return false;
            if (!string.Equals(Arabic, other.Arabic, StringComparison.Ordinal)) return false;
            return true;

        }

        public override bool Equals(object obj)
        {
            return ReferenceEquals(this, obj) || (obj is LocalizationRecord other && Equals(other));
        }

        public override int GetHashCode()
        {
            HashCode hash = new();
            hash.Add(Index);
            hash.Add(Key);
            hash.Add(Description);
            hash.Add(English);
            hash.Add(Korean);
            hash.Add(Spanish);
            hash.Add(Chinese);
            hash.Add(French);
            hash.Add(German);
            hash.Add(Indonesian);
            hash.Add(Japanese);
            hash.Add(Portuguese);
            hash.Add(Russian);
            hash.Add(Vietnamese);
            hash.Add(Italian);
            hash.Add(Arabic);

            return hash.ToHashCode();
        }

        public static bool operator ==(LocalizationRecord left, LocalizationRecord right)
        {
            return Equals(left, right);
        }

        public static bool operator !=(LocalizationRecord left, LocalizationRecord right)
        {
            return !Equals(left, right);
        }
        #endregion

        #region Indexer
        private readonly struct FieldInfo
        {
            public readonly int Index;
            public readonly Func<LocalizationRecord, object> Accessor;

            public FieldInfo(int index, Func<LocalizationRecord, object> accessor)
            {
                Index = index;
                Accessor = accessor;
            }
        }

        private static readonly Dictionary<string, FieldInfo> _fieldInfos;
        private static readonly FieldInfo[] _indexedFields;

        static LocalizationRecord()
        {
            _fieldInfos = new Dictionary<string, FieldInfo>(StringComparer.Ordinal)
            {
                ["Index"] = new FieldInfo(0, record => record.Index),
                ["Key"] = new FieldInfo(1, record => record.Key),
                ["Description"] = new FieldInfo(2, record => record.Description),
                ["English"] = new FieldInfo(3, record => record.English),
                ["Korean"] = new FieldInfo(4, record => record.Korean),
                ["Spanish"] = new FieldInfo(5, record => record.Spanish),
                ["Chinese"] = new FieldInfo(6, record => record.Chinese),
                ["French"] = new FieldInfo(7, record => record.French),
                ["German"] = new FieldInfo(8, record => record.German),
                ["Indonesian"] = new FieldInfo(9, record => record.Indonesian),
                ["Japanese"] = new FieldInfo(10, record => record.Japanese),
                ["Portuguese"] = new FieldInfo(11, record => record.Portuguese),
                ["Russian"] = new FieldInfo(12, record => record.Russian),
                ["Vietnamese"] = new FieldInfo(13, record => record.Vietnamese),
                ["Italian"] = new FieldInfo(14, record => record.Italian),
                ["Arabic"] = new FieldInfo(15, record => record.Arabic),
            };

            _indexedFields = new FieldInfo[]
            {
                new FieldInfo(0, record => record.Index),
                new FieldInfo(1, record => record.Key),
                new FieldInfo(2, record => record.Description),
                new FieldInfo(3, record => record.English),
                new FieldInfo(4, record => record.Korean),
                new FieldInfo(5, record => record.Spanish),
                new FieldInfo(6, record => record.Chinese),
                new FieldInfo(7, record => record.French),
                new FieldInfo(8, record => record.German),
                new FieldInfo(9, record => record.Indonesian),
                new FieldInfo(10, record => record.Japanese),
                new FieldInfo(11, record => record.Portuguese),
                new FieldInfo(12, record => record.Russian),
                new FieldInfo(13, record => record.Vietnamese),
                new FieldInfo(14, record => record.Italian),
                new FieldInfo(15, record => record.Arabic),
            };
        }

        public object this[int fieldIndex]
        {
            get
            {
                if ((uint)fieldIndex >= _indexedFields.Length)
                    throw new ArgumentOutOfRangeException(nameof(fieldIndex));
                return _indexedFields[fieldIndex].Accessor(this);
            }
        }

        public object this[string fieldName]
        {
            get
            {
                if (fieldName == null)
                {
                    throw new ArgumentNullException(nameof(fieldName));
                }

                if (!_fieldInfos.TryGetValue(fieldName, out var fieldInfo))
                    throw new KeyNotFoundException($"Field '{fieldName}' not found.");
                return fieldInfo.Accessor(this);
            }
        }
        #endregion
    }
}
